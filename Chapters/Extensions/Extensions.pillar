!!Extending the Pharo debugger
The debugger is extendable with user-defined problem-specific debugging tools.
Both views and debugging model can be tweaked to become applicable to a user's problem.
Views are extendable through the moldability of the Spec framework.
The Pharo debugging model is accessible through the Sindarin debugging API, with which users write debugging scripts and extend debugging actions.

Different aspects of the debugger are extendable: the toolbar, contexts menus (stack, code editor and context inspector) and the right column.

!!!The debugger tools extensions
The right column extends the debugger with additional tools.
These tools have access to the debugging model features and state through the Sindarin API (Chapter **Sindarin**).
They use this API to provide customized, problem-specific actions and views of the debugged execution.

++SCREENSHOT HERE++

!!!!Implementing a debugger extension
First, a spec presenter must be implemented.
It will be the view displayed in one tab of the extension column.
Spec presenters are subclasses of ==SpPresenter==.
These presenters must implement specific methods and state to be considered as valid extensions.
These methods are described below:


""==debuggingExtensionToolName==.""
This is a class-side method containing a specific pragma that defines the presenter as an extension.
This method must return a string that will be the title of the extension tab in the debugger.
An example is shown in the following script for the bytecode extension of the debugger.

[[[
StSindarinBytecodeDebuggerPresenter class >> debuggingExtensionToolName
	<debuggerExtensionOrder: 2 showByDefault: true>
	^ 'Bytecode'
]]]

The pragma actually enables instances of that presenter to be used as a debugger extension.
It has two parameters:
- the order in which the view will appear in the debugger extension column tabs
- a boolean that shows or not the extension by default in the debugger

Once the pragma defined in this method, these two parameters automatically appear in the settings under ==Tools >> Debugging >> Debugger Extensions==.
An additional setting named ''activate debugger extensions'' switches on and off all debugger extensions.


""==setModelBeforeInitialization: aStDebugger==.""
This is an instance-side method.
It is automatically called by the debugger when instantiating the extension view before initializing it.
It passes a model as parameter, that is always the current debugger for which the extension view is instantiated.
That method must, if needed, use the debugger to retrieve whatever model the extension needs.
For example (see code below), the bytecode extension needs the debugger itself and an instance of a Sindarin debugger to script the execution.
Developers must implement the needed instance variables and methods for each extension accordingly.

[[[
StSindarinBytecodeDebuggerPresenter >> setModelBeforeInitialization: aStDebugger
	"My original model is the debugger presenter that I extend"
	stDebugger := aStDebugger.
	sindarinDebugger := aStDebugger sindarinDebugger
]]]



""==updatePresenter==.""



To do so, the debugger enumerates its extensions and calls the ==updatePresenter== method.
This method is implemented by ==SpPresenter== and must be reimplemented by all tools.

extendedDebuggingToolTitle ==> convention method name to retrieve the name of a tool
	<debuggerExtensionPresentationOrder> ==> pragma to declare the tool
	^ 'Sindarin' ==> Returns string naming a tool

That name is used in the settings and in the

Must implement a setting that defines the order of appearance of the tool view in the right column of the debugger. ==> ==order==
Muss implement a setting that defines if the tool is active. ==> ==isActivated==

Tools presenters must all declare those variables.
They could be declared in a super class, for example ==SpPresenter==, but that would prevent users to inherit from other presenter subclasses of ==SpPresenter==.

Additional tool-specific settings can be added by adding corresponding class variables and defining the setting as above.


++EXAMPLE HERE++


!!!!Interaction between a tool extension and the extended debugger

Tools extensions are instantiated and registered by the debugger.
When the debugger is updated, e.g. while a single step has been performed, all registered tools are notified of that update.

Tools extensions also hold a reference to the debugger so that they may perform actions with it, e.g. trigger an update.
When a specific tool updates the debugger, the debugger also notifies all registered extensions.

Tools might have to turn the debugger updating service off while they act on the current debug session to avoid systematic refresh of the debugger view while they work.
Give the example of debugging scripts.


!!!Context menus and toolbar extensions

Context menus and toolbar extensions are either standalone (they perform a user-defined action or debugging script) or associated to a tool extending the debugger.

!!!!Standalone: Sindarin script or custom user-defined action
!!!!Tool-related extension

Extensions are collected through pragmas
The debugger toolbar is extendable by developing a command class with the <debuggerToolbarExtension>
The debugger inspector context menu is extendable by developing a command class with the <debuggerToolbarExtension>
